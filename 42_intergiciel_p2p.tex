%!TEX root = main.tex
%\chapter{Implantation}
%editeur...
%\section{Intergiciel P2P pour l'échange de données 3D}
%\subsubsection{La virtualisation des clients}
%\label{virtualisation}
%\todo{mettre ailleurs?}
%Une des problématiques soulevée par la collaboration \gls{P2P} est de permettre 
%la reproductibilité des expérimentations dans un environnement contrôlé et 
%réaliste.
%Réussir à simuler un réseau virtuel de clients en \gls{P2P} en utilisant le 
%protocole 
%\gls{WebRTC} est un défi encore compliqué. Il existe des outils pour simuler des 
%réseaux \gls{P2P} tels que PeerSim \cite{Montresor2009} ou \textit{ns-3} 
%\cite{Riley2010}. Ces outils sont 
%plus orientés sur la façon de distribuer les informations lors de la simulation et 
%leur 
%dissémination au sein du réseau plutôt que de reproduire les protocoles et 
%l'infrastucture de manière réaliste avec des données issues de l'\gls{IU}. Dans 
%de 
%récents travaux utilisant \gls{WebRTC}, les expérimentations ne 
%sont pas encore facilement reproductibles du fait qu'il n'existe pas d'outil facile à 
%prendre en main pour effectuer ce genre de simulation à base d'entrées 
%utilisateur 
%fiables vis à vis des impératifs métier. 
%
%La virtualisation implique également de pouvoir simuler des comportements sur 
%la base d'interactions issues de \gls{IU} \cite{Hu2017} comme on peut le trouver 
%dans la simulation d'\gls{IU} web.
%Dans ce contexte, ce type de tests permet de vérifier la compatibilité et la 
%réactivité des différentes plateformes, versions de navigateurs et types 
%d'appareils 
%en fonction d'entrées utilisateur. C'est également utile pour faire des tests de 
%performance ou de montée en charge 
%concernant l'interface. 
%Le service testRTC\footnote{\url{testrtc.com}. Consulté le 
%	07/07/2017} est un service payant qui propose un outil de test et de monitoring 
%pour un grand banc de machines de sessions audio et vidéo WebRTC .
%
%
%%TODO mettre ailleurs?
%L'intérêt d'utiliser un modèle de réseau \gls{P2P} virtuel comporte plusieurs 
%avantages. En reprenant les points proposés par \cite{Haque2016}, on peut citer 
%: 
%\begin{itemize}
%	\item Pas d'installation nécessaire. Plusieurs outils et logiciels existent pour 
%	simuler des réseaux \gls{P2P} \cite{Montresor2009} ou nécessite encore 
%	l'installation de clients lourds (clients BitTorrent) par les utilisateurs pour 
%réaliser 
%	les mesures. Cela implique le fait de comprendre les principes de base 
%	concernant la configuration réseau (routeurs, pare-feu) et le protocole utilisé 
%	(BitTorrent). Très peu de travaux concernant \gls{WebRTC} ont réussi à 
%	virtualiser les clients participants aux expérimentations.
%	\item Opérabilité et interopérabilité dans un environnement contrôlé.  
%	L'installation d'un client sur une machine requiert certaines autorisations liés à 
%	la politique de l'organisation, la licence logicielle et le support logiciel. Ce type 
%	d'environnement est assez typique dans l'industrie, c'est pourquoi il est 
%	intéressant de proposer un modèle qui puisse s'exécuter sans difficulté grâce 
%à 
%	l'utilisation de clients web. Les navigateurs qui servent de clients web 
%	s'accordent généralement avec les standards proposés par le \gls{W3C}, ce 
%qui 
%	facilite également l'interopérabilité du logiciel souvent déployé dans un parc 
%	hétérogène de machines.
%	\item Indépendance de la situation géographique. Tout comme les 
%	infrastructures \textit{cloud} (souvent un service tiers) qui sont distantes par 
%	l'intermédiaire d'un réseau , généralement internet les utilisateurs peuvent se 
%	connecter sur un réseau virtuel  \gls{P2P} à partir de n'importe quel lieu. 
%	\item Simplification de la maintenance. Les applications, standards et 
%	protocoles autour du \gls{P2P} sont en constante évolution. L'implémentation 
%de 
%	la méthode de distribution des données nécessite par conséquent de 
%fréquente 
%	mises à jour pour être la plus efficace possible. Dans le cas d'une 
%	implémentation d'un client virtuel, la mise à jour qui est distribuée par le 
%serveur 
%	sera automatique et la même sur tous les clients ce qui facilite la 
%maintenance 
%	car c'est le distributeur qui est responsable de la mise à jour et non le client.
%	\item Mobilité et accès au réseau. La mise en place d'un réseau P2P permet 
%de 
%	découpler l'accès à l'information et aux ressources du système. De ce fait, 
%	les clients peuvent travailler directement entre eux sans supervision après 
%mise 
%	en relation et partager leurs ressources avec les autres clients qui en ont 
%	besoin. Le réseau peut évoluer sans que cela ait un fort impact sur la 
%	collaboration. Les clients peuvent être plus mobiles du fait de la grande 
%	disponibilité offerte par cette architecture à moindre coût.
%	\item \gls{NATT} et pare feu. Les applications traditionnelles de P2P comme 
%	BitTorrent ne permettent pas à deux pairs de communiquer directement 
%	lorsqu'ils sont derrière un \gls{NAT}. Grâce à l'utilisation du protocole \gls{ICE} 
%	les appareils peuvent atteindre plus de pairs, augmentant la vitesse d'échange.
%\end{itemize}
%
%Cette liste est un point de départ pour créer un service de virtualisation de 
%clients 
%pour le partage de données (3D) avec WebRTC. 
%La mise à disposition volontaire de ressources (calcul, mémoire) en partage sur 
%le 
%réseau permet d'une part la coopération entre personnes afin de résoudre des 
%problèmes nécessitant un haut degré de computation et d'autre part l'utilisation 
%de 
%ressources qui ne seraient pas ou sous utilisées.
%
%
%
%
%En 2001, le standard \gls{DDS} est un standard machine-à-machine massif, en 
%temps-réel, hautement performant avec un système d'échange de données 
%interopérables. \gls{DDS} s'adresse principalement à des problématiques 
%d'échanges financiers, de contrôle aérien, et de réseau électrique intelligent 
%(\textit{smart grid}). Il a fortement été promu pour mettre en place des 
%applications 
%liées à l'internet des objets. Les spécifications proposent deux niveaux 
%d'interfaces. Le premier se concentre sur la mise à disposition d'un système 
%\gls{PubSub} bas niveau centré données pour permettre la livraison efficace de 
%la 
%bonne information au bon destinataire. Le second, niveau optionnel, 
%est une couche de reconstruction locale de la donnée permettant une integration 
%plus simple de \gls{DDS} au sein d'une application. \gls{DDS} est donc un 
%intergiciel réseau basé sur une architecture \gls{PubSub} qui gère la livraison 
%de messages sans nécessiter l'intervention d'un utilisateur. Il détermine qui doit 
%recevoir les messages, où sont situés les destinataires et ce qu'il se passe si 
%un 
%message n'est pas délivré. En cela, \gls{DDS} permet une gestion plus fine de la 
%qualité de service notamment concernant les paramètres de découverte des 
%pairs.



L'assomption est faite que tous les clients utilisent des navigateurs qui 
implémentent et supportent le protocole WebSocket et l'\gls{API} 
RTCDataChannel. 

La topologie de l'architecture de communication repose sur la mise en relation 
automatique des clients par le biais du serveur pour établir une connexion 
\gls{WebRTC}. Pour ce faire, chaque client envoie son identifiant (ID) lors de sa 
première requête au serveur qui le stocke. Selon le paramétrage de la connectivité 
directe minimum établie préalablement, le serveur recherche aléatoirement l'ID 
d'autres clients qui satisfont la règle de connectivité. Cette règle de connectivité 
minimum permet d'ajuster la densité du maillage (connectivité élevée: maillage 
partiel dense, voire complet ; connectivité faible: maillage partiel éparse) et 
d'obtenir une topologie maillée adaptée aux besoins de l'application en termes de 
synchronisation (temps-réel ou non) ou aux capacités des appareils. Il faut noter 
cependant que plus la connectivité est faible, plus l'information a besoin de transiter par des intermédiaires pour atteindre tous les pairs et par conséquent le temps de 
transmission est augmenté (exemple d'une distribution en ligne). 

\subsubsection{Implantation du serveur}
La connexion entre un pair (client) et le serveur est établie sur la base du protocole 
\gls{WebSocket}. Cette connexion bi-directionnelle est initialisée lors de la 
première requête du client pour récupérer le contenu de l'application. Cette 
connexion sert à la fois pour la phase de \textit{signaling} lors de l'établissement 
d'une connexion \gls{WebRTC} mais également pour que le client puisse envoyer 
des mises à jours originales à la base de données via les pairs reliés à la base de 
données. 

Lors de la phase de \textit{signaling} c'est donc la partie gestion des instances du 
serveur qui gère la politique de connexion des données. Dans le prototype réalisé 
la connectivité minimum entre les différents pairs participant à la même scène est 
fixée à 2. Cette politique permet de créer un maillage réseau qui n'est pas trop 
dense en considérant que le nombre maximum d'utilisateur dépassera pas dix.



\subsubsection{De navigateur à navigateur}
Lors de la connexion d'un nouveau client à la scène, le serveur effectue la phase 
de \textit{signaling} permettant de le mettre en relation avec un autre client. Le 
mécanisme est répété tant que la règle de connectivité peut s'appliquer. Le client 
reçoit une notification de l'établissement de la connexion avec un autre client ce 
qui lui permet de démarrer l'échange de données.

L'API RTCDataChannel permet à chaque pair d'échanger des données arbitraires 
avec d'autres à partir du navigateur avec des propriétés de livraison 
personnalisables -- fiable ou non fiable (Section \ref{sec:fiabilite}), ordonné ou non 
ordonné (Section \ref{sec:ordre}). 

Dans 3DEvent, le choix d'avoir un transport 
fiable et non ordonné a été fait pour respectivement 
garantir l'arrivée d'une donnée émise par l'utilisateur au sein de l'application et 
permettre des échanges asynchrones.
\improve{add \S sur "en cas de défaillance? }
En cas d'arrêt soudain du serveur, si une connexion a été établie préalablement 
entre les clients et est toujours en cours, elle n'est pas impactée par la défaillance 
du serveur.

\subsection{Données d'échange}
En sachant que le modèle est conçu pour des applications web, 3DEvent a besoin 
d'un format de données permettant de faire communiquer des acteurs hétérogènes 
du système.
Le format \gls{JSON} est assez générique pour être aussi utilisé pour lors de la 
sérialisation et la désérialisation des 
événements et plus largement des paquets transmis par RTCDataChannel. 
L'\acrshort{API} RTCDataChannel supporte beaucoup de types de données 
différents (chaînes de caractères, types binaires : Blob, ArrayBuffer\dots). Dans 
un environnement multi-utilisateurs tel que 3DEvent avec des données 
hétérogènes (3D, images, 
informations) l'interopérabilité est facilitée.

Le Listing  \ref{jsonstore} représente la structure de données utilisée sur le réseau 
lorsqu'un événement est transmis. Seule la partie $data$ est utilisé au sein du pair 
pour faire les manipulations en \gls{CQRS} car le type de l'instance d'événement 
manipulé est connu. 

La structure représentant l'événement transporte un numéro de version \og 
attendue\fg{} 
qui correspond à la version que l'agrégat doit avoir lorsque l'événement lui est 
appliqué. De cette manière la cohérence interne du pair est maintenu grâce à ce 
numéro de version.
Les événements contenant les objets 3D ($importGeometryEvent$) ont une 
propriété contenant la géométrie sous la forme d'un Blob contenant le fichier. 
\\


%\begin{lstlisting}[language=json,firstnumber=1,label=jsonevent,caption=Événement
% MeshAddedToScene et ses paramètres]
%{
%	{
%		"sceneId": "scene-turbine",
%		"meshId":"406514c6-306b-f0f9643a037e",
%		"geometryId": "37076875-ea1c-bbd300481345",
%		"name": "blade",
%		"color": "#963912",
%		"version": 17,
%		"author": "Foo"
%	}
%}
%\end{lstlisting}

\begin{lstlisting}[language=json,firstnumber=1,label=jsonstore,caption=Format
 du Message transitant sur le réseau contenant l'événement MeshAddedToScene 
et ses 
paramètres]
{
	"packetId" : "567826g6-766b-f0g9676b677r",
	"streamId" : "scene-turbine",
	"eventType" : "MeshAddedToSceneEvent",
	"version" : 17,
	"data" : {
		"sceneId": "scene-turbine",
		"meshId":"406514c6-306b-f0f9643a037e",
		"geometryId": "37076875-ea1c-bbd300481345",
		"name": "blade",
		"color": "#963912",
		"author": "Foo"
	}
}
\end{lstlisting}

%\begin{lstlisting}[language=json,firstnumber=1,label=jsonexemple,caption=Format
%de l'événement MeshAddedToScene stocké dans la base de données Event 
%Store]
%{
%	"eventId": "9935bfa5-542e-2a44-add0-d3fb1abb7488",
%	"eventType": "MeshAddedToSceneEvent",
%	"eventNumber": 230,
%	"data": {
%		MeshAddedToSceneEvent : {
%			"sceneId": "scene-turbine",
%			"meshId":"406514c6-306b-f0f9643a037e",
%			"geometryId": "37076875-ea1c-bbd300481345",
%			"name": "blade",
%			"color": "#963912",
%			"version": 17,
%			"author": "Foo"
%		}
%	},
%	"streamId": "scene-work_living_room",
%	"positionEventNumber": 17,
%	"positionStreamId": "scene-work_living_room",
%	"title": "23@scene-work_living_room",
%	"id": "http://127.0.0.1:2113/streams/scene-work_living_room/17",
%	"updated": "2017-03-05T22:04:33.982814Z"
%}
%\end{lstlisting}
\subsection{Synchronisation des données}
\subsubsection{Persistance à court terme}
Le navigateur (client) offre un espace de stockage avec l'interface \textit{Storage} 
de l'API Web Storage qui donne accès au \texttt{session storage} ou au  
\texttt{local storage}. Ce stockage est présent sur le client et fonctionne sur un système de clé / valeur. La configuration du client est également 
stockée localement. Grâce à ce système, il est possible d'avoir une 
persistance des données à travers les sessions du navigateur. Le contenu stocké 
correspond aux données générées par un utilisateur et par ses collaborateurs. Les 
répliques stockées sur chaque navigateur permettent à un utilisateur une plus 
grande 
autonomie en cas de déconnexion. C'est également un moyen de distribuer entre les clients les 
mises à jour qu'ils génèrent grâce au protocole de 
\gls{streaming3D} (cf. \ref{streamingprotocol}) sans passer par le serveur.

événements enregistrés sur le client. La configuration du client est également 


\subsubsection{Protocole de streaming pour la synchronisation}
\label{streamingprotocol}

Il existe plusieurs méthodes de transmission de contenu au sein d'un réseau 
\gls{P2P} que l'on peut catégoriser selon deux modes : le téléchargement 
(\textit{download}) 
et le flux continu (\textit{streaming}). Le téléchargement requière que le contenu 
soit entièrement téléchargé pour pouvoir être lu, tandis que le flux continu peut 
être lu au fur et à mesure de sa récupération. Ce dernier mode, principalement 
utilisé pour la lecture de vidéo en ligne, s'applique bien à la transmission de 
contenu \gls{3D} : niveaux de détails \cite{Chu2012,Hu2008}, progressif 
\cite{Cheng2009,Limper2014}, mise en cache \cite{Jia2014}, compression / 
décompression
\cite{Lavoue2013,Ponchio2015,Maglo2013a}. 
Une catégorisation plus précise du flux continu peut être donnée selon quand le 
contenu est généré : 
en direct (\textit{live} ou \textit{push}) et à la demande (\textit{on-demand} ou 
\textit{pull}).  


Le mécanisme de routage que nous avons utilisé dans \cite{Desprat2015a} est 
proche du routage de GNutella. 





pour chaque event sauvé , l’Event store publie (push) l’event

\begin{algorithm} % enter the algorithm environment
	\caption{Sauvegarde d'événements d'un agrégat dans l'Event Store} % 
	%give the algorithm a caption
	\label{algo:saveEvent} % and a label for \ref{} commands later in the document
	\begin{algorithmic} % enter the algorithmic environment
		\REQUIRE aggregateId : string, uncommitedEvents : eventMsg[ ], 
		version : number
		%\ENSURE $y = x^n$
		\STATE $expectedVersion \Leftarrow version$
		\FOR{$eventMsg $ \textbf{in} $uncommitedEvents$}	
		\STATE{$newMsg \Leftarrow \{type : eventMsg.typeEvt, data : eventMsg, 
streamId : aggregateId\}$}
		\STATE{$publish(aggregateId, newMsg, expectedVersion++)$}
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm} % enter the algorithm environment
	\caption{Ajout d'un événement dans l'Event Store} % 
	%give the algorithm a caption
	\label{algo:addevent} % and a label for \ref{} commands later in the document
	\begin{algorithmic} % enter the algorithmic environment
		\REQUIRE streamId: string, event: EventStoreEvent, version: number
		\ENSURE event
		\STATE $stream \Leftarrow streams.getOrCreate(streamId);$
		\IF{$ stream.has(version)$}
		\STATE $throwExceptionVersion(stream,version)$
		\ENDIF
		\STATE $stream.data.set(version,event) $
	\end{algorithmic}
\end{algorithm}

    % publish(stream: string, event: DomainEvent, version: number) {
    %     let wrappedEvent = this.processEvent(stream, event, version);
    %     if(wrappedEvent) {
    %         for (var [to, node] of this.clusterNodes) {
    %             if (node.nodeState === NodeStatus.READY) {
    %                 //TODO revoir l'envoie des events, peut être par stream
    %                 node.sendEvent(stream, wrappedEvent, wrappedEvent.index)
    %             }
    %         }
    %     }
    % }
categories: type d’agregat
c’est un flux liés a une categorie (exemple geometries) tous les events liés à la 
categorie.

metadata phase sync permet a un nouveau noeud de recup toutes les info 
manquantes et de les demander de maniere repartie a tous les noeuds


\begin{algorithm} % enter the algorithm environment
	\caption{Synchronisation d'un n\oe ud de l'Event Store partagé} % 
	%give the algorithm a caption
	\label{algo:synchnode} % and a label for \ref{} commands later in the document
	\begin{algorithmic} % enter the algorithmic environment
		\REQUIRE $node : ClusterNode$
		\ENSURE $nodeState == synchronized$
		\STATE $nodeMetadata \Leftarrow node.getMetadata()$
		\IF{$nodeMetadata != \{\} $}
			\STATE $streamsToSync \Leftarrow metadata.getDiff(nodeMetadata)$
			\WHILE{$streamsToSync > 0$}
				\STATE $streamToSync \Leftarrow streamsToSync.pop()$
				\STATE $events \Leftarrow  node.getEvents(streamToSync)$
				\IF{$! streamToSync.has(version)$}
					\FOR {$event$ \textbf{in} $events$}
						\STATE $processEvent(event.streamName, event, 
						event.version)$
					\ENDFOR 
				\ENDIF
				\STATE $streamsToSync \Leftarrow metadata.getDiff(nodeMetadata)$
			\ENDWHILE
		\ENDIF
		\STATE $node.endSync()$
	\end{algorithmic}
\end{algorithm}

L'algorithme \ref{algo:synchnode} décrit la synchronisation d'un n\oe ud avec un 
autre n\oe ud dans l'Event Store partagé. Le n\oe ud courant demande le 
différentiel (\textit{diff}) entre ses streams et ceux du n\oe ud $node$ pour 
connaître quels sont les streams à synchroniser. 
et le plus rapide repond et ça continue jusqu’a synchro . ignore si deja present.


%private *syncFromNode(node: ClusterNode) {     let metadata = yield 
%node.getMetaData();     if (!metadata.isEmpty()) {         let syncStreams: 
%SyncStream[] = this.metadata.diff(metadata);         while (syncStreams.length > 
%0) 
%{             let syncStream:SyncStream = syncStreams.pop();             let events 
%= 
%yield node.getEvents(syncStream);             if 
%(!this.streams.has(syncStream.name) || 
%!this.streams.get(syncStream.name).has(syncStream.version)) {                 for 
%(let 
%i = 0; i < events.length; i++) {                     let event = events[i];                     if 
%(!this.streams.has(event.streamName) || 
%!this.streams.get(event.streamName).has(event.version)) {                         
%this.processEvent(event.streamName, event, event.version);                     
%}                 }             } else {                 LOGGER.debug(node.from, node.to, 
%syncStream.name);             }             syncStreams = 
%this.metadata.diff(metadata);         }         node.endSync();     }     
%node.endSync();     yield Promise.resolve(true); }



\subsubsection{Gestion des événements des agrégats}

Une connexion RTCDataChannel peut être configurée selon 
les critères (Section \todo{ref section config}) de fiabilité et d'ordonnancement. 
Dans l'intergiciel de 3DEvent, cette configuration est : non fiable et non ordonnée. 
C'est l'application qui est en charge de \og ré-ordonner\fg{} les événements. En 
effet, les événements sont associés à des agrégats. Comme chaque agrégat 
possède un flux d'événements dédié et numéroté il est alors simple pour l'application de les 
ordonner lorsqu'elle les réceptionne. 
Lors de la synchronisation (Section \todo{ref section sync}), les 
événements manquants sont demandés successivement à tous les pairs. Lors 
qu'un pair reçoit les événements il les stocke dans le flux correspondant à 
l'agrégat. Si un événement est manquant, les suivants sont quand même stockés 
en laissant l'espace de l'événement manquant dans le tableau. L'événement est 
redemandé jusqu'à son obtention, laquelle provoque le déblocage de l'état de 
l'agrégat jusqu'au prochain événement manquant (ou la fin du flux). Les 
événements qui ont été stockés \og en attendant\fg{} permettent à l'application 
d'être directement en capacité de poursuivre la construction de l'état de l'agrégat. 
Cette mécanique tire avantage des Snapshots (présentés dans \todo{ref section}) 
qui réduisent la taille des flux en mémoire pour chaque agrégat qui part déjà d'un 
état avancé.


\begin{figure}
	\centering
	\inputTikZ{0.9}{eps/tikz/streams/aggregate.tex}
	\caption{Exemple d'agrégats}{Structure d'un agrégat et ses versions. Chaque 
	version est un état de l'agrégat qui correspond à l'empilement des instances 
	d'événements (ei) qu'il contient. Les types des événements sont relatifs au type 
	d'agrégat dans lequel il est contenu.}
	\label{fig:aggregate}
\end{figure}

