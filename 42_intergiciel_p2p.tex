%!TEX root = main.tex
%\chapter{Implantation}
%editeur...
%\section{Intergiciel P2P pour l'échange de données 3D}
L'assomption est faite que tous les clients utilisent des navigateurs qui 
implémentent et supportent le protocole WebSocket et l'\gls{API} 
RTCDataChannel. 

La topologie de l'architecture de communication repose sur la mise en relation 
automatique des clients par le biais du serveur pour établir une connexion 
\gls{WebRTC}. Pour ce faire, chaque client envoie son identifiant (ID) lors de sa 
première requête au serveur qui le stocke. Selon le paramétrage de la connectivité 
directe minimum établie préalablement, le serveur recherche aléatoirement l'ID 
d'autres clients qui satisfont la règle de connectivité. Cette règle de connectivité 
minimum permet d'ajuster la densité du maillage (connectivité élevée: maillage 
partiel dense voire complet ; connectivité faible: maillage partiel éparse) et 
d'obtenir une topologie maillée adaptée aux besoins de l'application en termes de 
synchronisation (temps-réel ou pas) ou aux capacités des appareils. Il faut noter 
cependant que plus la connectivité est faible, plus l'information a besoin de « 
rebondir » pour atteindre tous les pairs et par conséquent le temps de 
transmission est augmenté (exemple d'une distribution en ligne). 

\subsubsection{De navigateur à serveur}
La connexion entre un pair (client) et le serveur est établie sur la base du protocole 
\gls{WebSocket}. Cette connexion bi-directionnelle est initialisée lors de la 
première requête du client pour récupérer le contenu de l'application. Cette 
connexion sert à la fois pour la phase de \textit{signaling} lors de l'établissement 
d'une connexion WebRTC mais également pour que le client puisse envoyer des 
mises à jours originales à la base de données via le serveur.

\subsubsection{De navigateur à navigateur}
Lors de la connexion d'un nouveau client à la scène, le serveur effectue la phase 
de signaling permettant de le mettre en relation avec un autre client. Le 
mécanisme est répété tant que la règle de connectivité peut s'appliquer. Le client 
reçoit une notification de l'établissement de la connexion avec un autre client ce 
qui lui permet de démarrer l'échange de données.

L'API RTCDataChannel permet à chaque pair d'échanger des données arbitraires 
avec d'autres à partir du navigateur avec des propriétés de livraison 
personnalisables (fiable ou non fiable, ordonné ou non ordonné) selon le transport 
sous-jacent\info{GrI13}. Dans 3DEvent, le choix d'avoir un transport fiable 
\unsure{fiable ou pas fiable et pk...}et non ordonné a été fait pour respectivement 
garantir l'arrivée d'une donnée émise par l'utilisateur au sein de l'application et 
permettre des échanges asynchrones.
\improve{add \S sur "en cas de défaillance? }
En cas d'arrêt soudain du serveur, si une connexion a été établie préalablement 
entre les clients et est toujours en cours, elle n'est pas impactée par la défaillance 
du serveur.
\subsection{Données d'échange}
En sachant que le modèle est conçu pour des applications web, 3DEvent a besoin 
d'un format de données permettant de faire communiquer des acteurs hétérogènes 
du système. Le format \gls{JSON}, dérivé de la notation des objets du langage 
JavaScript, il est lisible et interopérable. 
%Son pendant binaire est le format \gls{BSON}.
Le format de fichier \gls{glTF} se base sur la représentation \gls{JSON} afin de 
décrire une scène 3D.
Ce type de données est assez abstrait et suffisamment générique pour 
représenter n'importe quelle donnée. Par exemple le format de fichier 
\gls{glTF}\info{ref gltf section}se base sur la représentation \gls{JSON} afin de 
décrire une scène 3D.
Le format \gls{JSON} est aussi utilisé pour la sérialisation et la désérialisation des 
objets transmis par RTCDataChannel qui prend n'importe quel format de données.

L'\acrshort{API} RTCDataChannel supporte beaucoup de types de données 
différents (chaînes de caractères, types binaires : Blob, ArrayBuffer\dots). Dans 
un environnement multi-utilisateur avec des données hétérogènes (3D, images, 
informations) tel que 3DEvent cela facilite l'interopérabilité.


\subsection{Synchronisation des données}
\subsubsection{Persistance à court terme}
Le navigateur (client) offre un espace de stockage avec l'interface \textit{Storage} 
de l'API Web Storage qui donne accès au \texttt{session storage} ou au  
\texttt{local storage}. Grâce à un système clé/valeur, il est possible d'avoir une 
persistance des données à travers les sessions du navigateur. Le contenu stocké 
correspond aux données générées par un utilisateur et par ses collaborateurs. Les 
répliques stockées sur chaque navigateur permettent à un utilisateur une plus 
grande 
autonomie en cas de déconnexion. C'est également un moyen de distribuer les 
mises à jour générées par les clients entre les clients grâce au protocole de 
\gls{streaming3D} (cf. \ref{streamingprotocol}) sans passer par le serveur.

Ce stockage fonctionne sur un système de clé/valeur qui rend facile l'accès aux 
évènements enregistrés sur le client. La configuration du client est également 
stockée localement. 

\subsubsection{Protocole de streaming pour la synchronisation}
\label{streamingprotocol}

Il existe plusieurs méthodes de transmission de contenu au sein d'un réseau P2P 
que l'on peut catégoriser selon deux modes : le téléchargement (\textit{download}) 
et le flux continu (\textit{streaming}). Le téléchargement requière que le contenu 
soit entièrement téléchargé pour pouvoir être lu. Tandis que le flux continu peut 
être lu au fur et à mesure de sa récupération. Ce mode est principalement utilisé 
pour la lecture de vidéo en ligne. En comparaison le mode téléchargement est 
moins restrictif et relativement simple à mettre en place. Tout comme les 
systèmes utilisant une architecture client-serveur, la transmission de contenu en 
P2P peut également être catégorisée selon ces deux modes. Une catégorisation 
plus précise du flux continu peut être donnée selon quand le contenu est généré : 
en direct (live) et à la demande (\textit{on-demand}).


Le mécanisme de routage que nous avons utilisé dans \cite{Desprat2015a} est 
proche du routage de GNutella. 



\begin{table}[]
	\centering
	\small
	\caption{Type de messages lors de la synchronisation}
	\label{table:messagetype}
	\begin{tabular}{ll}
		 \toprule
		\textbf{Message}                & \textbf{Description} \\ \hline
		STREAM\_SYNC\_ASK      &  Demande de synchronisation d'un 
		\textit{stream}           \\
		CHUNK                  &     Réception d'une donnée \textit{chunk})        
		\\
		READY\_ASK             &      Prêt pour la démarrer la demande de 
		données de 
		sync.        \\
		READY                  &       Prêt pour démarrer la réception de 
		données de 
		sync.      \\
		ALL\_EVENTS\_SYNC\_ASK &     Demande de toutes les données 
		typées 
		évènement           \\
		EVENTS\_SYNC           &        Réception de données (en cours de 
		synchronisation)       \\
		META\_DATA\_ASK        &     Demande de métadonnées       \\
		META\_DATA             &      Réception de métadonnées       \\
		SYNC                   &      Réception de données (en cours de 
		synchronisation)         \\
		EVENT                  &     Réception d'une donnée typée 
		évènement        \\
		END\_SYNC              & Fin de la synchronisation \\ \bottomrule
	\end{tabular}
\end{table}
\todo{parler des tableaux}

\begin{table}[]
	\centering
	\caption{Statut du n\oe ud}
	\label{table:nodestatus}
	\begin{tabular}{ll}
		\toprule
		\textbf{Message}             & \textbf{Description} \\ \midrule
		ERROR               &      En erreur (désynchronisation)       \\
		READY               &       Prêt à recevoir des messages      \\
		META\_DATA\_ASK     &      En demande de métadonnées       \\
		META\_DATA\_RECEIVE &      En réception de métadonnées       \\
		CLOSE               &     Déconnecté (connexion fermée)        \\
		RECEIVE\_SYNC       &      En réception de données à synchroniser    \\
		CONNECTED           &      Connecté (connexion ouverte)        \\
		INIT                &     Initialisation   \\
		OK                  &    Connecté et synchronisé      \\
		SEND\_SYNC          &    En demande de synchronisation         \\
		END\_SYNC           &      Synchronisation terminée      \\ \bottomrule
	\end{tabular}
\end{table}