%!TEX root = main.tex
%\chapter{Implantation}
%editeur...
%\section{Intergiciel P2P pour l'échange de données 3D}
%\subsubsection{La virtualisation des clients}
%\label{virtualisation}
%\todo{mettre ailleurs?}
%Une des problématiques soulevée par la collaboration \gls{P2P} est de permettre 
%la reproductibilité des expérimentations dans un environnement contrôlé et 
%réaliste.
%Réussir à simuler un réseau virtuel de clients en \gls{P2P} en utilisant le 
%protocole 
%\gls{WebRTC} est un défi encore compliqué. Il existe des outils pour simuler des 
%réseaux \gls{P2P} tels que PeerSim \cite{Montresor2009} ou \textit{ns-3} 
%\cite{Riley2010}. Ces outils sont 
%plus orientés sur la façon de distribuer les informations lors de la simulation et 
%leur 
%dissémination au sein du réseau plutôt que de reproduire les protocoles et 
%l'infrastucture de manière réaliste avec des données issues de l'\gls{IU}. Dans 
%de 
%récents travaux utilisant \gls{WebRTC}, les expérimentations ne 
%sont pas encore facilement reproductibles du fait qu'il n'existe pas d'outil facile à 
%prendre en main pour effectuer ce genre de simulation à base d'entrées 
%utilisateur 
%fiables vis à vis des impératifs métier. 
%
%La virtualisation implique également de pouvoir simuler des comportements sur 
%la base d'interactions issues de \gls{IU} \cite{Hu2017} comme on peut le trouver 
%dans la simulation d'\gls{IU} web.
%Dans ce contexte, ce type de tests permet de vérifier la compatibilité et la 
%réactivité des différentes plateformes, versions de navigateurs et types 
%d'appareils 
%en fonction d'entrées utilisateur. C'est également utile pour faire des tests de 
%performance ou de montée en charge 
%concernant l'interface. 
%Le service testRTC\footnote{\url{testrtc.com}. Consulté le 
%	07/07/2017} est un service payant qui propose un outil de test et de monitoring 
%pour un grand banc de machines de sessions audio et vidéo WebRTC .
%
%
%%TODO mettre ailleurs?
%L'intérêt d'utiliser un modèle de réseau \gls{P2P} virtuel comporte plusieurs 
%avantages. En reprenant les points proposés par \cite{Haque2016}, on peut citer 
%: 
%\begin{itemize}
%	\item Pas d'installation nécessaire. Plusieurs outils et logiciels existent pour 
%	simuler des réseaux \gls{P2P} \cite{Montresor2009} ou nécessite encore 
%	l'installation de clients lourds (clients BitTorrent) par les utilisateurs pour 
%réaliser 
%	les mesures. Cela implique le fait de comprendre les principes de base 
%	concernant la configuration réseau (routeurs, pare-feu) et le protocole utilisé 
%	(BitTorrent). Très peu de travaux concernant \gls{WebRTC} ont réussi à 
%	virtualiser les clients participants aux expérimentations.
%	\item Opérabilité et interopérabilité dans un environnement contrôlé.  
%	L'installation d'un client sur une machine requiert certaines autorisations liés à 
%	la politique de l'organisation, la licence logicielle et le support logiciel. Ce type 
%	d'environnement est assez typique dans l'industrie, c'est pourquoi il est 
%	intéressant de proposer un modèle qui puisse s'exécuter sans difficulté grâce 
%à 
%	l'utilisation de clients web. Les navigateurs qui servent de clients web 
%	s'accordent généralement avec les standards proposés par le \gls{W3C}, ce 
%qui 
%	facilite également l'interopérabilité du logiciel souvent déployé dans un parc 
%	hétérogène de machines.
%	\item Indépendance de la situation géographique. Tout comme les 
%	infrastructures \textit{cloud} (souvent un service tiers) qui sont distantes par 
%	l'intermédiaire d'un réseau , généralement internet les utilisateurs peuvent se 
%	connecter sur un réseau virtuel  \gls{P2P} à partir de n'importe quel lieu. 
%	\item Simplification de la maintenance. Les applications, standards et 
%	protocoles autour du \gls{P2P} sont en constante évolution. L'implémentation 
%de 
%	la méthode de distribution des données nécessite par conséquent de 
%fréquente 
%	mises à jour pour être la plus efficace possible. Dans le cas d'une 
%	implémentation d'un client virtuel, la mise à jour qui est distribuée par le 
%serveur 
%	sera automatique et la même sur tous les clients ce qui facilite la 
%maintenance 
%	car c'est le distributeur qui est responsable de la mise à jour et non le client.
%	\item Mobilité et accès au réseau. La mise en place d'un réseau P2P permet 
%de 
%	découpler l'accès à l'information et aux ressources du système. De ce fait, 
%	les clients peuvent travailler directement entre eux sans supervision après 
%mise 
%	en relation et partager leurs ressources avec les autres clients qui en ont 
%	besoin. Le réseau peut évoluer sans que cela ait un fort impact sur la 
%	collaboration. Les clients peuvent être plus mobiles du fait de la grande 
%	disponibilité offerte par cette architecture à moindre coût.
%	\item \gls{NATT} et pare feu. Les applications traditionnelles de P2P comme 
%	BitTorrent ne permettent pas à deux pairs de communiquer directement 
%	lorsqu'ils sont derrière un \gls{NAT}. Grâce à l'utilisation du protocole \gls{ICE} 
%	les appareils peuvent atteindre plus de pairs, augmentant la vitesse d'échange.
%\end{itemize}
%
%Cette liste est un point de départ pour créer un service de virtualisation de 
%clients 
%pour le partage de données (3D) avec WebRTC. 
%La mise à disposition volontaire de ressources (calcul, mémoire) en partage sur 
%le 
%réseau permet d'une part la coopération entre personnes afin de résoudre des 
%problèmes nécessitant un haut degré de computation et d'autre part l'utilisation 
%de 
%ressources qui ne seraient pas ou sous utilisées.
%
%
%
%
%En 2001, le standard \gls{DDS} est un standard machine-à-machine massif, en 
%temps-réel, hautement performant avec un système d'échange de données 
%interopérables. \gls{DDS} s'adresse principalement à des problématiques 
%d'échanges financiers, de contrôle aérien, et de réseau électrique intelligent 
%(\textit{smart grid}). Il a fortement été promu pour mettre en place des 
%applications 
%liées à l'internet des objets. Les spécifications proposent deux niveaux 
%d'interfaces. Le premier se concentre sur la mise à disposition d'un système 
%\gls{PubSub} bas niveau centré données pour permettre la livraison efficace de 
%la 
%bonne information au bon destinataire. Le second, niveau optionnel, 
%est une couche de reconstruction locale de la donnée permettant une integration 
%plus simple de \gls{DDS} au sein d'une application. \gls{DDS} est donc un 
%intergiciel réseau basé sur une architecture \gls{PubSub} qui gère la livraison 
%de messages sans nécessiter l'intervention d'un utilisateur. Il détermine qui doit 
%recevoir les messages, où sont situés les destinataires et ce qu'il se passe si 
%un 
%message n'est pas délivré. En cela, \gls{DDS} permet une gestion plus fine de la 
%qualité de service notamment concernant les paramètres de découverte des 
%pairs.



L'assomption est faite que tous les clients utilisent des navigateurs qui 
implémentent et supportent le protocole WebSocket et l'\gls{API} 
RTCDataChannel. 

La topologie de l'architecture de communication repose sur la mise en relation 
automatique des clients par le biais du serveur pour établir une connexion 
\gls{WebRTC}. Pour ce faire, chaque client envoie son identifiant (ID) lors de sa 
première requête au serveur qui le stocke. Selon le paramétrage de la connectivité 
directe minimum établie préalablement, le serveur recherche aléatoirement l'ID 
d'autres clients qui satisfont la règle de connectivité. Cette règle de connectivité 
minimum permet d'ajuster la densité du maillage (connectivité élevée: maillage 
partiel dense, voire complet ; connectivité faible: maillage partiel éparse) et 
d'obtenir une topologie maillée adaptée aux besoins de l'application en termes de 
synchronisation (temps-réel ou non) ou aux capacités des appareils. Il faut noter 
cependant que plus la connectivité est faible, plus l'information a besoin de transiter par des intermédiaires pour atteindre tous les pairs et par conséquent le temps de 
transmission est augmenté (exemple d'une distribution en ligne). 

\subsubsection{De navigateur à serveur}
La connexion entre un pair (client) et le serveur est établie sur la base du protocole 
\gls{WebSocket}. Cette connexion bi-directionnelle est initialisée lors de la 
première requête du client pour récupérer le contenu de l'application. Cette 
connexion sert à la fois pour la phase de \textit{signaling} lors de l'établissement 
d'une connexion WebRTC mais également pour que le client puisse envoyer des 
mises à jours originales à la base de données via le serveur.

\subsubsection{De navigateur à navigateur}
Lors de la connexion d'un nouveau client à la scène, le serveur effectue la phase 
de \textit{signaling} permettant de le mettre en relation avec un autre client. Le 
mécanisme est répété tant que la règle de connectivité peut s'appliquer. Le client 
reçoit une notification de l'établissement de la connexion avec un autre client ce 
qui lui permet de démarrer l'échange de données.

L'API RTCDataChannel permet à chaque pair d'échanger des données arbitraires 
avec d'autres à partir du navigateur avec des propriétés de livraison 
personnalisables -- fiable ou non fiable (Section \ref{sec:fiabilite}), ordonné ou non 
ordonné (Section \ref{sec:ordre}). 

Dans 3DEvent, le choix d'avoir un transport 
fiable et non ordonné a été fait pour respectivement 
garantir l'arrivée d'une donnée émise par l'utilisateur au sein de l'application et 
permettre des échanges asynchrones.
\improve{add \S sur "en cas de défaillance? }
En cas d'arrêt soudain du serveur, si une connexion a été établie préalablement 
entre les clients et est toujours en cours, elle n'est pas impactée par la défaillance 
du serveur.

\subsection{Données d'échange}
En sachant que le modèle est conçu pour des applications web, 3DEvent a besoin 
d'un format de données permettant de faire communiquer des acteurs hétérogènes 
du système. Le format \gls{JSON}, dérivé de la notation des objets du langage 
JavaScript, est lisible et interopérable. Le Listing \ref{jsonexemple} montre un 
exemple d'événement en format JSON.
%Son pendant binaire est le format \gls{BSON}.
%Le format de fichier \gls{glTF} se base sur la représentation \gls{JSON} afin de 
%décrire une scène 3D.
Ce type de données est assez abstrait et suffisamment générique pour 
représenter n'importe quelle donnée. Par exemple le format de fichier 
\gls{glTF}\info{ref gltf section} se base sur la représentation \gls{JSON} afin de 
décrire une scène 3D.
Le format \gls{JSON} est assez générique pour être aussi utilisé pour la sérialisation et la désérialisation des 
objets transmis par RTCDataChannel. 

L'\acrshort{API} RTCDataChannel supporte beaucoup de types de données 
différents (chaînes de caractères, types binaires : Blob, ArrayBuffer\dots). Dans 
un environnement multi-utilisateurs tel que 3DEvent avec des données hétérogènes (3D, images, 
informations) l'interopérabilité est facilitée.

\begin{lstlisting}[language=json,firstnumber=1,label=jsonexemple,caption=Mesh 
added to Scene event and parameters]
{
{
"sceneId": "scene-turbine",
"meshId":"406514c6-306b-f0f9643a037e",
"geometryId": "37076875-ea1c-bbd300481345",
"name": "blade",
"color": "#963912"
},
"version": 17,
"author": "Foo"
}
\end{lstlisting}

\subsection{Synchronisation des données}
\subsubsection{Persistance à court terme}
Le navigateur (client) offre un espace de stockage avec l'interface \textit{Storage} 
de l'API Web Storage qui donne accès au \texttt{session storage} ou au  
\texttt{local storage}. Ce stockage est présent sur le client et fonctionne sur un système de clé / valeur. La configuration du client est également 
stockée localement. Grâce à ce système, il est possible d'avoir une 
persistance des données à travers les sessions du navigateur. Le contenu stocké 
correspond aux données générées par un utilisateur et par ses collaborateurs. Les 
répliques stockées sur chaque navigateur permettent à un utilisateur une plus 
grande 
autonomie en cas de déconnexion. C'est également un moyen de distribuer entre les clients les 
mises à jour qu'ils génèrent grâce au protocole de 
\gls{streaming3D} (cf. \ref{streamingprotocol}) sans passer par le serveur.

événements enregistrés sur le client. La configuration du client est également 


\subsubsection{Protocole de streaming pour la synchronisation}
\label{streamingprotocol}

Il existe plusieurs méthodes de transmission de contenu au sein d'un réseau P2P 
que l'on peut catégoriser selon deux modes : le téléchargement (\textit{download}) 
et le flux continu (\textit{streaming}). Le téléchargement requière que le contenu 
soit entièrement téléchargé pour pouvoir être lu, tandis que le flux continu peut 
être lu au fur et à mesure de sa récupération. Ce dernier mode, principalement 
utilisé pour la lecture de vidéo en ligne, s'applique bien à la transmission de 
contenu 3D : niveaux de détails \cite{Chu2012,Hu2008}, progressif 
\cite{Cheng2009,Limper2014}, mise en cache \cite{Jia2014}, compression / 
décompression
\cite{Lavoue2013,Ponchio2015,Maglo2013a}. 
Une catégorisation plus précise du flux continu peut être donnée selon quand le 
contenu est généré : 
en direct (\textit{live} ou \textit{push}) et à la demande (\textit{on-demand} ou 
\textit{pull}).  


Le mécanisme de routage que nous avons utilisé dans \cite{Desprat2015a} est 
proche du routage de GNutella. 



\subsubsection{Gestion des événements des agrégats}

La configuration des connexions RTCDataChannel peut être configurée de selon 
les critères (Section \todo{ref section config}) de fiabilité et d'ordonnancement. 
Dans l'intergiciel de 3DEvent, cette configuration est : non fiable et non ordonnée. 
C'est l'application qui est en charge de \og ré-ordonner\fg{} les événements. En 
effet, les événements sont associés à des agrégats. Comme chaque agrégat 
possède un flux d'événements dédié et numéroté il est alors simple de les 
ordonner lorsque. 
Lors de la synchronisation (Section \todo{ref section sync}), les 
événements manquants sont demandés successivement à tous les pairs. Lors 
qu'un pair reçoit les événements il les stocke dans le flux correspondant à 
l'agrégat. Si un événement est manquant, les suivants sont quand même stockés 
en laissant l'espace de l'événement manquant dans le tableau. L'événement est 
redemandé jusqu'à son obtention, laquelle provoque le déblocage de l'état de 
l'agrégat jusqu'au prochain événement manquant (ou la fin du flux). Les 
événements qui ont été stockés \og en attendant\fg{} permettent à l'application 
d'être directement en capacité de poursuivre la construction de l'état de l'agrégat. 
Cette mécanique tire avantage des Snapshots (présentés dans \todo{ref section}) 
qui réduisent la taille des flux en mémoire pour chaque agrégat qui part déjà d'un 
état avancé.

\subsubsection{Sélection fantôme}
Les interactions utilisateurs doivent être adaptées à la collaboration et aux 
manipulations à effectuer. Pour cela, l'éditeur 3DEvent introduit la fonctionnalité de 
sélection \og fantôme\fg{}. Lorsqu'un utilisateur souhaite sélectionner un objet de 
la scène, l'objet original ($O_o$) est 
cloné et devient l'objet fantôme ($O_f$) (mêmes propriétés, représenté avec de la 
transparence d'où le terme \og fantôme\fg{}). 
L'objet $O_f$ prend alors le focus de sélection pour que l'utilisateur le manipule à 
la place de l'objet $O_f$. 
En différenciant l'actuel objet que l'utilisateur souhaite sélectionné ($O_{o}$) de 
celui manipulé ($O_f$), l'interaction est mise en valeur sous quatre angles :
\begin{itemize}
	\item l'ergonomie dans l'environnement 3D :
	$O_f$ est un objet temporaire qui permet à l'utilisateur
	d'avoir une visualisation de l'objet en cours de manipulation tout en 
	conservant le dernier état de $O_o$ visible. 
	$O_o$ peut être considéré comme un point de repère visuel pour l'utilisateur 
	lorsqu'il effectue sa manipulation. 
	L'$O_f$ a aussi un rôle d'intermédiaire entre l'utilisateur et la 
	finalité de l'interaction en donnant un support visuel à sa réflexion experte.
	Grâce à $O_f$, l'utilisateur peut également révoquer sa manipulation en 
	cours sans avoir eu d'impact sur $O_o$ en évitant des actions inutiles (faire l'action 
	puis la défaire) pour le métier et coûteuses pour le réseau.
	
	\item la collaboration : si un collaborateur effectue une modification 
	à destination du même $O_o$ alors la représentation de $O_o$ chez 
	l'utilisateur est également modifiée. $O_f$ par contre ne subit pas d'impact ; 
	l'utilisateur peut continuer sa manipulation et~/~ou l'ajuster en fonction des 
	nouvelles informations liées à $O_o$ ou même révoquer sa manipulation 
	en cours si cela lui convient.

	\item le métier : seules les manipulations menées à terme sont 
	considérées comme des commandes. Cela évite d'avoir des événements qui ne 
	sont pas pertinents pour le métier dans le journal d'événements (comme lorsque 
	l'utilisateur change d'idée lors de l'interaction ou
	suite à une intervention concurrente). L'utilisateur n'a un impact sur l'application 
	que lorsqu'une modification métier est réalisée.
	
	\item le réseau : l'information importante à faire transité est l'événement 
	correspondant à la modification métier pas toutes les positions intermédiaires 
	même si intuitivement l'idée de temps réel pourrait conduire à cette solution. La 
	quantité de messages produite surchargerai à la fois le réseau et le fil 
	d'exécution principale de l'application. En effet, \gls{WebRTC} a l'inconvénient pour le 
	moment de ne pas pouvoir s'exécuter dans un \textit{Web Worker} (fil d'exécution 
	parallèle en JavaScript). Cette solution imposerai des 
	latences réseau et d'\gls{IU} qui affecteraient gravement l'expérience utilisateur
	sans apporter d'informations supplémentaires à l'aspect métier de la 
	collaboration. 
\end{itemize}

Lorsque l'utilisateur relâche $O_f$, alors la modification intentée s'applique sur 
$O_o$ avec le principe du \textit{Last Write Last Win} (le dernier gagne).