%!TEX root = main.tex
%\chapter{Implantation}
%editeur...
%\section{Intergiciel P2P pour l'échange de données 3D}
%\subsubsection{La virtualisation des clients}
%\label{virtualisation}
%\todo{mettre ailleurs?}
%Une des problématiques soulevée par la collaboration \gls{P2P} est de permettre 
%la reproductibilité des expérimentations dans un environnement contrôlé et 
%réaliste.
%Réussir à simuler un réseau virtuel de clients en \gls{P2P} en utilisant le 
%protocole 
%\gls{WebRTC} est un défi encore compliqué. Il existe des outils pour simuler des 
%réseaux \gls{P2P} tels que PeerSim \cite{Montresor2009} ou \textit{ns-3} 
%\cite{Riley2010}. Ces outils sont 
%plus orientés sur la façon de distribuer les informations lors de la simulation et 
%leur 
%dissémination au sein du réseau plutôt que de reproduire les protocoles et 
%l'infrastucture de manière réaliste avec des données issues de l'\gls{IU}. Dans 
%de 
%récents travaux utilisant \gls{WebRTC}, les expérimentations ne 
%sont pas encore facilement reproductibles du fait qu'il n'existe pas d'outil facile à 
%prendre en main pour effectuer ce genre de simulation à base d'entrées 
%utilisateur 
%fiables vis à vis des impératifs métier. 
%
%La virtualisation implique également de pouvoir simuler des comportements sur 
%la base d'interactions issues de \gls{IU} \cite{Hu2017} comme on peut le trouver 
%dans la simulation d'\gls{IU} web.
%Dans ce contexte, ce type de tests permet de vérifier la compatibilité et la 
%réactivité des différentes plateformes, versions de navigateurs et types 
%d'appareils 
%en fonction d'entrées utilisateur. C'est également utile pour faire des tests de 
%performance ou de montée en charge 
%concernant l'interface. 
%Le service testRTC\footnote{\url{testrtc.com}. Consulté le 
%	07/07/2017} est un service payant qui propose un outil de test et de monitoring 
%pour un grand banc de machines de sessions audio et vidéo WebRTC .
%
%
%%TODO mettre ailleurs?
%L'intérêt d'utiliser un modèle de réseau \gls{P2P} virtuel comporte plusieurs 
%avantages. En reprenant les points proposés par \cite{Haque2016}, on peut citer 
%: 
%\begin{itemize}
%	\item Pas d'installation nécessaire. Plusieurs outils et logiciels existent pour 
%	simuler des réseaux \gls{P2P} \cite{Montresor2009} ou nécessite encore 
%	l'installation de clients lourds (clients BitTorrent) par les utilisateurs pour 
%réaliser 
%	les mesures. Cela implique le fait de comprendre les principes de base 
%	concernant la configuration réseau (routeurs, pare-feu) et le protocole utilisé 
%	(BitTorrent). Très peu de travaux concernant \gls{WebRTC} ont réussi à 
%	virtualiser les clients participants aux expérimentations.
%	\item Opérabilité et interopérabilité dans un environnement contrôlé.  
%	L'installation d'un client sur une machine requiert certaines autorisations liés à 
%	la politique de l'organisation, la licence logicielle et le support logiciel. Ce type 
%	d'environnement est assez typique dans l'industrie, c'est pourquoi il est 
%	intéressant de proposer un modèle qui puisse s'exécuter sans difficulté grâce 
%à 
%	l'utilisation de clients web. Les navigateurs qui servent de clients web 
%	s'accordent généralement avec les standards proposés par le \gls{W3C}, ce 
%qui 
%	facilite également l'interopérabilité du logiciel souvent déployé dans un parc 
%	hétérogène de machines.
%	\item Indépendance de la situation géographique. Tout comme les 
%	infrastructures \textit{cloud} (souvent un service tiers) qui sont distantes par 
%	l'intermédiaire d'un réseau , généralement internet les utilisateurs peuvent se 
%	connecter sur un réseau virtuel  \gls{P2P} à partir de n'importe quel lieu. 
%	\item Simplification de la maintenance. Les applications, standards et 
%	protocoles autour du \gls{P2P} sont en constante évolution. L'implémentation 
%de 
%	la méthode de distribution des données nécessite par conséquent de 
%fréquente 
%	mises à jour pour être la plus efficace possible. Dans le cas d'une 
%	implémentation d'un client virtuel, la mise à jour qui est distribuée par le 
%serveur 
%	sera automatique et la même sur tous les clients ce qui facilite la 
%maintenance 
%	car c'est le distributeur qui est responsable de la mise à jour et non le client.
%	\item Mobilité et accès au réseau. La mise en place d'un réseau P2P permet 
%de 
%	découpler l'accès à l'information et aux ressources du système. De ce fait, 
%	les clients peuvent travailler directement entre eux sans supervision après 
%mise 
%	en relation et partager leurs ressources avec les autres clients qui en ont 
%	besoin. Le réseau peut évoluer sans que cela ait un fort impact sur la 
%	collaboration. Les clients peuvent être plus mobiles du fait de la grande 
%	disponibilité offerte par cette architecture à moindre coût.
%	\item \gls{NATT} et pare feu. Les applications traditionnelles de P2P comme 
%	BitTorrent ne permettent pas à deux pairs de communiquer directement 
%	lorsqu'ils sont derrière un \gls{NAT}. Grâce à l'utilisation du protocole \gls{ICE} 
%	les appareils peuvent atteindre plus de pairs, augmentant la vitesse d'échange.
%\end{itemize}
%
%Cette liste est un point de départ pour créer un service de virtualisation de 
%clients 
%pour le partage de données (3D) avec WebRTC. 
%La mise à disposition volontaire de ressources (calcul, mémoire) en partage sur 
%le 
%réseau permet d'une part la coopération entre personnes afin de résoudre des 
%problèmes nécessitant un haut degré de computation et d'autre part l'utilisation 
%de 
%ressources qui ne seraient pas ou sous utilisées.
%
%
%
%
%En 2001, le standard \gls{DDS} est un standard machine-à-machine massif, en 
%temps-réel, hautement performant avec un système d'échange de données 
%interopérables. \gls{DDS} s'adresse principalement à des problématiques 
%d'échanges financiers, de contrôle aérien, et de réseau électrique intelligent 
%(\textit{smart grid}). Il a fortement été promu pour mettre en place des 
%applications 
%liées à l'internet des objets. Les spécifications proposent deux niveaux 
%d'interfaces. Le premier se concentre sur la mise à disposition d'un système 
%\gls{PubSub} bas niveau centré données pour permettre la livraison efficace de 
%la 
%bonne information au bon destinataire. Le second, niveau optionnel, 
%est une couche de reconstruction locale de la donnée permettant une integration 
%plus simple de \gls{DDS} au sein d'une application. \gls{DDS} est donc un 
%intergiciel réseau basé sur une architecture \gls{PubSub} qui gère la livraison 
%de messages sans nécessiter l'intervention d'un utilisateur. Il détermine qui doit 
%recevoir les messages, où sont situés les destinataires et ce qu'il se passe si 
%un 
%message n'est pas délivré. En cela, \gls{DDS} permet une gestion plus fine de la 
%qualité de service notamment concernant les paramètres de découverte des 
%pairs.



L'assomption est faite que tous les clients utilisent des navigateurs qui 
implémentent et supportent le protocole WebSocket et l'\gls{API} 
RTCDataChannel. 

La topologie de l'architecture de communication repose sur la mise en relation 
automatique des clients par le biais du serveur pour établir une connexion 
\gls{WebRTC}. Pour ce faire, chaque client envoie son identifiant (ID) lors de sa 
première requête au serveur qui le stocke. Selon le paramétrage de la connectivité 
directe minimum établie préalablement, le serveur recherche aléatoirement l'ID 
d'autres clients qui satisfont la règle de connectivité. Cette règle de connectivité 
minimum permet d'ajuster la densité du maillage (connectivité élevée: maillage 
partiel dense voire complet ; connectivité faible: maillage partiel éparse) et 
d'obtenir une topologie maillée adaptée aux besoins de l'application en termes de 
synchronisation (temps-réel ou pas) ou aux capacités des appareils. Il faut noter 
cependant que plus la connectivité est faible, plus l'information a besoin de « 
rebondir » pour atteindre tous les pairs et par conséquent le temps de 
transmission est augmenté (exemple d'une distribution en ligne). 

\subsubsection{De navigateur à serveur}
La connexion entre un pair (client) et le serveur est établie sur la base du protocole 
\gls{WebSocket}. Cette connexion bi-directionnelle est initialisée lors de la 
première requête du client pour récupérer le contenu de l'application. Cette 
connexion sert à la fois pour la phase de \textit{signaling} lors de l'établissement 
d'une connexion WebRTC mais également pour que le client puisse envoyer des 
mises à jours originales à la base de données via le serveur.

\subsubsection{De navigateur à navigateur}
Lors de la connexion d'un nouveau client à la scène, le serveur effectue la phase 
de signaling permettant de le mettre en relation avec un autre client. Le 
mécanisme est répété tant que la règle de connectivité peut s'appliquer. Le client 
reçoit une notification de l'établissement de la connexion avec un autre client ce 
qui lui permet de démarrer l'échange de données.

L'API RTCDataChannel permet à chaque pair d'échanger des données arbitraires 
avec d'autres à partir du navigateur avec des propriétés de livraison 
personnalisables (fiable ou non fiable, ordonné ou non ordonné) selon le transport 
sous-jacent\info{GrI13}. Dans 3DEvent, le choix d'avoir un transport fiable 
\unsure{fiable ou pas fiable et pk...}et non ordonné a été fait pour respectivement 
garantir l'arrivée d'une donnée émise par l'utilisateur au sein de l'application et 
permettre des échanges asynchrones.
\improve{add \S sur "en cas de défaillance? }
En cas d'arrêt soudain du serveur, si une connexion a été établie préalablement 
entre les clients et est toujours en cours, elle n'est pas impactée par la défaillance 
du serveur.
\subsection{Données d'échange}
En sachant que le modèle est conçu pour des applications web, 3DEvent a besoin 
d'un format de données permettant de faire communiquer des acteurs hétérogènes 
du système. Le format \gls{JSON}, dérivé de la notation des objets du langage 
JavaScript, il est lisible et interopérable. 
%Son pendant binaire est le format \gls{BSON}.
Le format de fichier \gls{glTF} se base sur la représentation \gls{JSON} afin de 
décrire une scène 3D.
Ce type de données est assez abstrait et suffisamment générique pour 
représenter n'importe quelle donnée. Par exemple le format de fichier 
\gls{glTF}\info{ref gltf section}se base sur la représentation \gls{JSON} afin de 
décrire une scène 3D.
Le format \gls{JSON} est aussi utilisé pour la sérialisation et la désérialisation des 
objets transmis par RTCDataChannel qui prend n'importe quel format de données.

L'\acrshort{API} RTCDataChannel supporte beaucoup de types de données 
différents (chaînes de caractères, types binaires : Blob, ArrayBuffer\dots). Dans 
un environnement multi-utilisateur avec des données hétérogènes (3D, images, 
informations) tel que 3DEvent cela facilite l'interopérabilité.


\subsection{Synchronisation des données}
\subsubsection{Persistance à court terme}
Le navigateur (client) offre un espace de stockage avec l'interface \textit{Storage} 
de l'API Web Storage qui donne accès au \texttt{session storage} ou au  
\texttt{local storage}. Grâce à un système clé/valeur, il est possible d'avoir une 
persistance des données à travers les sessions du navigateur. Le contenu stocké 
correspond aux données générées par un utilisateur et par ses collaborateurs. Les 
répliques stockées sur chaque navigateur permettent à un utilisateur une plus 
grande 
autonomie en cas de déconnexion. C'est également un moyen de distribuer les 
mises à jour générées par les clients entre les clients grâce au protocole de 
\gls{streaming3D} (cf. \ref{streamingprotocol}) sans passer par le serveur.

Ce stockage fonctionne sur un système de clé/valeur qui rend facile l'accès aux 
évènements enregistrés sur le client. La configuration du client est également 
stockée localement. 

\subsubsection{Protocole de streaming pour la synchronisation}
\label{streamingprotocol}

Il existe plusieurs méthodes de transmission de contenu au sein d'un réseau P2P 
que l'on peut catégoriser selon deux modes : le téléchargement (\textit{download}) 
et le flux continu (\textit{streaming}). Le téléchargement requière que le contenu 
soit entièrement téléchargé pour pouvoir être lu. Tandis que le flux continu peut 
être lu au fur et à mesure de sa récupération. Ce mode est principalement utilisé 
pour la lecture de vidéo en ligne. En comparaison le mode téléchargement est 
moins restrictif et relativement simple à mettre en place. Tout comme les 
systèmes utilisant une architecture client-serveur, la transmission de contenu en 
P2P peut également être catégorisée selon ces deux modes. Une catégorisation 
plus précise du flux continu peut être donnée selon quand le contenu est généré : 
en direct (live) et à la demande (\textit{on-demand}).


Le mécanisme de routage que nous avons utilisé dans \cite{Desprat2015a} est 
proche du routage de GNutella. 



\begin{table}[]
	\centering
	\small
	\caption{Type de messages lors de la synchronisation}
	\label{table:messagetype}
	\begin{tabular}{ll}
		 \toprule
		\textbf{Message}                & \textbf{Description} \\ \hline
		STREAM\_SYNC\_ASK      &  Demande de synchronisation d'un 
		\textit{stream}           \\
		CHUNK                  &     Réception d'une donnée \textit{chunk})        
		\\
		READY\_ASK             &      Prêt pour la démarrer la demande de 
		données de 
		sync.        \\
		READY                  &       Prêt pour démarrer la réception de 
		données de 
		sync.      \\
		ALL\_EVENTS\_SYNC\_ASK &     Demande de toutes les données 
		typées 
		évènement           \\
		EVENTS\_SYNC           &        Réception de données (en cours de 
		synchronisation)       \\
		META\_DATA\_ASK        &     Demande de métadonnées       \\
		META\_DATA             &      Réception de métadonnées       \\
		SYNC                   &      Réception de données (en cours de 
		synchronisation)         \\
		EVENT                  &     Réception d'une donnée typée 
		évènement        \\
		END\_SYNC              & Fin de la synchronisation \\ \bottomrule
	\end{tabular}
\end{table}
\todo{parler des tableaux}

\begin{table}[]
	\centering
	\caption{Statut du n\oe ud}
	\label{table:nodestatus}
	\begin{tabular}{ll}
		\toprule
		\textbf{Message}             & \textbf{Description} \\ \midrule
		ERROR               &      En erreur (désynchronisation)       \\
		READY               &       Prêt à recevoir des messages      \\
		META\_DATA\_ASK     &      En demande de métadonnées       \\
		META\_DATA\_RECEIVE &      En réception de métadonnées       \\
		CLOSE               &     Déconnecté (connexion fermée)        \\
		RECEIVE\_SYNC       &      En réception de données à synchroniser    \\
		CONNECTED           &      Connecté (connexion ouverte)        \\
		INIT                &     Initialisation   \\
		OK                  &    Connecté et synchronisé      \\
		SEND\_SYNC          &    En demande de synchronisation         \\
		END\_SYNC           &      Synchronisation terminée      \\ \bottomrule
	\end{tabular}
\end{table}