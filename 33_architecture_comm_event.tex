\subsection{Architecture de hybride \og orientée événements\fg{}}
\label{sec:comm_event}



\subsubsection{Persistance à long terme}\label{sec:persistance-a-long-terme}
Dans un contexte industriel de collaboration, l'information doit être disponible sur le 
long terme, facilement accessible par l'entreprise. La persistance à 
long-terme stocke le journal d'événement qui est la 
source de vérité de l'application. Elle peut également stocker des projections 
prédéfinies, calculées à la volée ou encore des \textit{snapshots} de l'application.

\subsubsection{Synchronisation client-serveur}
\label{sec:synchronisation-client-serveur}

Les travaux \cite{Desprat2015a} et \cite{Desprat2015b} présentent une version 
naïve du processus de synchronisation. La cohérence est garantie par un système 
de verrouillage des objets.

Lors de la connexion d'un nouveau client a lieu la synchronisation des deux 
systèmes de persistance pour obtenir les mises à jour : 
\improve{l'échange des mises à jour entre le client (persistance à court terme) et la 
	base de données (à long terme) afin de synchroniser les deux éléments avec. 
	La 
	base de données peut également servir en cas de conflit important ; elle sert de 
	référent.}
\improve{synchro- nizing with a NoSQL-based database whenever possible 
	(thereby supporting intermittent connections of mobile devices; this approach is 
	known as “offline first”) \cite{Gadea2016}}
\begin{enumerate}
	\item depuis le client, où l'on distingue trois cas :
	\begin{enumerate}
		\item travail "\textit{offline}" (hors ligne) : l'utilisateur a travaillé hors ligne et 
		doit maintenant publier "en ligne" son travail. Les mises à jour publiées sur la 
		base de données ; le serveur vérifie si aucun conflit ne survient puis 
		fusionne (\textit{merge}) les nouvelles entrées avec l'existant; 
		
		\item travail "\textit{serverless}" (en collaboration avec d'autres pairs sans le 
		serveur) : dans le cas où le serveur est absent, les clients peuvent continuer 
		de créer en collaborant. Ces données n'étant stockées que sur le client, il est 
		nécessaire de les transmettre à la base de données dès qu'une connexion 
		est possible. 
		Cela peut être fait en une fois ou de manière partagée\improve{ça veut dire 
			quoi?};
		
		\item travail "\textit{online}" (en collaboration avec d'autres pairs avec le 
		serveur) : le client envoie régulièrement \improve{combien de temps} ses 
		nouvelles modifications pour qu'elles soient intégrées à la base de données.
	\end{enumerate}
	\item depuis la base de données :
	Le client reçoit toutes les nouvelles mises à jour de la scène depuis la dernière 
	fois qu'il s'est connecté. Cela peut également inclure des mises à jour qui sont 
	en conflit avec ce qu'il y a dans son propre espace de stockage qu'il lui faut 
	donc modifier.
	Dans le cas où un utilisateur est seul connecté, la base de données est la 
	seule source disponible pour la mise à jour du client. 
\end{enumerate}


\subsubsection{Mécanisme de gestion de version}
3DEvent intègre une procédure de gestion de version dans l'\gls{EventStore} afin 
de gérer au mieux la cohérence des données. 
Chaque gestion de commande (Figure \ref{fig:gestionCommande}) entraîne la 
génération d'un ou plusieurs événements. Ces événements sont considérés 
comme \og soumis\fg{} (\textit{uncommitted}) mais pas encore <<~publiés~>> 
(\textit{committed}).  Pour qu'ils le deviennent, l'agrégat concerné par ces 
événements doit produire une nouvelle version sans être en conflit avec la 
précédente. En passant la version attendue $v_a$ au gestionnaire de conflit, on 
est à même de la comparer avec la version courante $v_c$. Il existe deux cas où 
un conflit est levé~: 
\begin{enumerate}[label=\alph*)]
	\item \label{i:vi} La version $v_a$ correspond à la valeur d'initialisation
	\item \label{i:vdiff} La version $v_a$ est différente de la version $v_c$
\end{enumerate}
Dans \ref{i:vi}, on s'assure qu'après une action la version initiale de l'agrégat ne 
peut être la même. Cet item peut sembler évident mais il est important de le noter 
car il dépend entièrement de la valeur initiale choisie pour les agrégats du 
\gls{framework} (on peut commencer à n'importe quelle valeur -- -1, 0\ldots).


%
%\subsubsection{Gestion de la cohérence}
%
%
%\subsubsection{Respect de la causalité}
%\subsubsection{Convergence des répliques}
%\subsubsection{Préservation de l'intention}
\subsubsection{Extension : Event Store distribué}


%\paragraph{Connexion des pairs en début de session}
Dans \cite{Desprat2017}, lorsqu'un pair initialise ou rejoint, la séquence pour 
rejoindre une session collaborative évolue 
pour prendre en considération l'intégration des événements et la synchronisation 
des journaux d'événements.
La Figure \ref{fig:connexionpairs} représente la séquence d'actions nécessaire à 
une instance 3DEvent ($idA$) pour rejoindre le réseau contenant déjà d'autres 
instances 3DEvent. L'action \textit{join} est exécutée lorsqu'un utilisateur envoie 
ses informations de connexion sur un portail de connexion (à partir d'une instance 
web) ou lorsqu'une instance serveur est lancée. Cette action ajoute le nouveau 
pair à la liste des pairs présents sur le réseau. La liste est gérée par le 
gestionnaire 
d'instance, et retourne la liste des pairs avec lesquels le pair doit se connecter. 
Pour chaque pair $idB$ de la liste retournée $ids$, $idA$ utilise le mécanisme de 
signalisation (offre/demande). Le mécanisme est déclenché par l'instanciation d'un 
\textit{network bridge}\info{definir} dans l'\textit{event store} \info{definir} de $idA$ 
puis celui de $idB$. Afin de resynchroniser les deux pairs (après cette série 
d'échanges asynchrones), $idA$ et $idB$ s'échangent des métadonnées sur la 
situation respective de leurs \textit{ESM} \info{definir} afin de se synchroniser 
\info{(see refernece sync mechanism}.

\begin{figure}[h]
	\noindent
	\centering
	\includegraphics[width=\columnwidth]{connection.eps}
	\caption{Protocole de connexion au réseau d'instance 3DEvent}
	\label{fig:connexionpairs}
\end{figure}



L'Event Store est un composant clé dans le traitement des événements. Il prend 
en entrée des événements générés ou reçus extérieurement et produit en sortie 
des événements cohérents qui peuvent être par la suite publiés. Les événements 
sont considérés comme cohérents lorsqu'il n'y a pas d'erreur de cohérence, i.e. 
lorsque les numéros de versions sont bien ordonnés. Chaque Event Store contient 
deux éléments: l'Event Stream Manager (ESM) et des Network Bridges (NB). Un
ESM est une structure de données représentée par une collection de flux 
d'événements. Un flux d'événement est représenté par un tableau d'événements 
indexés en séquence permettant de stocker les événements d'un aggrégat dans 
l'ordre temporel. Si un flux ne rencontre pas de problème de cohérence alors le 
dernier index correspond au numéro de version de l'agrégat. Lorsque l'Event Store 
reçoit un événement de l'instance courante\info{utilisation du terme 
	instance?}, l'ESM récupère (ou crée) le flux d'événements associé à l'agrégat 
référencé par l'événement. Alors, la cohérence de la version est vérifiée en 
comparant la version attendue (exposée dans les métadonnées de l'événement) 
et la version actuelle de l'agrégat. Si les deux numéros de versions sont égaux, 
l'événement est ajouté à la fin du tableau du flux pour être stocké, sinon une 
exception est levée. La gestion des exceptions est expliquée dans \info{détails 
	exception}. Une fois le stockage effectué dans l'ESM, l'événement est publié.